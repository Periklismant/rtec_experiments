\documentclass[a4paper,10pt]{article}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{etoolbox}% http://ctan.org/pkg/etoolbox
\usepackage{pstricks,pst-node,pst-text,pst-3d}
\usepackage{graphicx}
\usepackage{verbatim} 
%\usepackage{paralist}
\usepackage{tabularx} 
\usepackage{booktabs}
%\usepackage{algorithm}
\usepackage[noend]{algorithmic}
%\usepackage{subcaption}
\usepackage{caption}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{listings}
\DeclareMathOperator{\val}{=}  % for p=v atoms
\DeclareMathOperator{\notval}{\neq}  % for p=v atoms

\def \patsize {}

\def\recogniseSimpleFluent{\textsf{\patsize recogniseSimpleFluent}}
\def\recogniseSDFluent{\textsf{\patsize recogniseSDFluent}}
\def\makeintervals{\textsf{\footnotesize makeIntervals}}
\def\happensAt{\textsf{\patsize happensAt}}
\def\happens{\textsf{\patsize happensAt}}
\def\happensFor{\textsf{\footnotesize happensFor}}
\def\initially{\textsf{\footnotesize initially}}
\def\holdsAt{\textsf{\patsize holdsAt}}
\def\holdsFor{\textsf{\patsize holdsFor}}
\def\holdsForSDFluent{\textsf{\footnotesize holdsForSDFluent}}
\def\holdsAtSDFluent{\textsf{\footnotesize holdsAtSDFluent}}
\def\holdsForSimpleFluent{\textsf{\footnotesize holdsForSimpleFluent}}
\def\holdsForRecognisedSimpleFluent{\textsf{\footnotesize holdsForRecognisedSimpleFluent}}
\def\holdsForRecognisedSDFluent{\textsf{\footnotesize holdsForRecognisedSDFluent}}
\def\holdsAtRecognisedSimpleFluent{\textsf{\footnotesize holdsAtRecognisedSimpleFluent}}
\def\initiatedAt{\textsf{\patsize initiatedAt}}
\def\terminatedAt{\textsf{\patsize terminatedAt}}
\def\maxduration{\textsf{\patsize maxDuration}}
\def\maxdurationue{\textsf{\patsize maxDurationUE}}
\def\brokenOnce{\textsf{\patsize brokenOnce}}
\def\startedBetween{\textsf{\patsize startedBetween}}
\def\startingPoints{\textsf{\patsize startingPoints}}
\def\member{\textsf{\patsize member}}
\def\addStartingPoint{\textsf{\patsize addStartingPoint}}


\def\bror{\textsf{\patsize brokenOrReInitiated}}
\def\itim{\textsf{\patsize initTime}}
\def\inof{\textsf{\patsize indexOf}}
\def\groun{\textsf{\patsize grounding}}
\def\termPoint{\textsf{\patsize termPoint}}
\def\nextTimePoint{\textsf{\patsize nextTimePoint}}
\def\simpleFluent{\textsf{\patsize simpleFluent}}

\def\initiates{\textsf{\footnotesize initiates}}
\def\terminates{\textsf{\footnotesize terminates}}
\def\broken{\textsf{\patsize broken}}
\def\startE{\textsf{\patsize start}}
\def\startI{\textsf{\patsize startI}}

\def\endE{\textsf{\patsize end}}

\def\simpleFList{\textsf{\footnotesize simpleFList}}
\def\sdFList{\textsf{\footnotesize sdFList}}

\def\unionall{\textsf{\patsize union\_all}}
\def\isetunion{\textsf{\footnotesize union}}
\def\intersectall{\textsf{\patsize intersect\_all}}
\def\isetintersection{\textsf{\footnotesize intersection}}
\def\complementall{\textsf{\patsize relative\_complement\_all}}
\def\abscomplementall{\textsf{\footnotesize complement\_all}}
\def\isetdifference{\textsf{\footnotesize relative\_complement}}

\def\nbf{\textsf{\patsize not}}
\def\true{\textsf{\patsize true}}
\def\false{\textsf{\patsize false}}
\def\since{\textsf{\patsize since}}
\newenvironment{mysplit}%
  {\arraycolsep 0pt \begin{array}{l}}%
  {\end{array}}
  
\newcommand\arraybslash{\let\\\@arraycr}
%\makeatother
% Footnote rule
\setlength{\skip\footins}{0.0469in}
\renewcommand\footnoterule{\vspace*{-0.0071in}\setlength\leftskip{0pt}\setlength\rightskip{0pt plus 1fil}\noindent\textcolor{black}{\rule{0.0\columnwidth}{0.0071in}}\vspace*{0.0398in}}
\setlength\tabcolsep{1mm}
\renewcommand\arraystretch{1.3}
\newcounter{Table}
\renewcommand\theTable{\arabic{Table}}
\DeclareMathOperator*{\argmin}{arg\,min}

\title{Unit tester : Manual}
\author{}
\date{}

\pdfinfo{%
  /Title    (Unit tester : Manual)
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\begin{document}
\maketitle
\section{Introduction}
This document provides a short manual on the RTEC-unit-tester and guidance on creating a simple set of unit tests. RTEC-unit-tester provides a way of testing the recognition results of RTEC using a set of narratives, rules, and testcases provided by the user (a human).
\section{Tests file}
Testing RTEC with the unit-tester requires a set of compiled rules and their declarations, one or more narratives and a declaration file of the tests.
In this section, we will describe the needed declarations for a test file, and provide guidance for the creation of a simple test file, testing the correctness
of the recognised intervals using the following rule:
\begin{lstlisting}[language=Prolog]
    initiatedAt(runningTest(X)=true,T):-
      happensAt(starts_test(X),T).
    terminatedAt(runningTest(X)=true,T):-
      happensAt(ends_test(X),T).
\end{lstlisting}
\subsection{Narratives}
A narrative must be declared in one of the following three forms:
\begin{lstlisting}[language=Prolog]
%Type A
updateSDE(exampleScenario) :-
  assert(happensAtIE(starts_test(unit_tester),1)),
  assert(happensAtIE(ends_test(unit_tester),10)).
%Type B  
updateSDE(exampleScenario,5) :-
  assert(happensAtIE(starts_test(unit_tester),1)).
updateSDE(exampleScenario,10) :-
  assert(happensAtIE(ends_test(unit_tester),10)).
%Type C
updateSDE(exampleScenario,0,5) :-
  assert(happensAtIE(starts_test(unit_tester),1)).
updateSDE(exampleScenario,5,10) :-
  assert(happensAtIE(ends_test(unit_tester),10)).
\end{lstlisting}
Type A uses only a scenario ID value, type B uses additionally an extra argument expressing the end time of the narrative and type C uses two extra arguments expressing the start time and the end time of the narrative. Narratives of type B and type C can be useful when testing unsorted narrative or running tests with windows. When the narratives are of type B or C, care must be taken when choosing the values of step and windowsize so that the start time in type c narratives is equal to the $CurrentTime-WM$ value of each recognition query and end time is equal to the current time. In each recogntion step, based on the test case declaration, the narrative with the corresponding scenario ID is loaded. If the test case declaration uses a type A narrative then the input events are asserted alltogether before event recognition starts, if the test case declaration uses a type B or C then the appropriate narrative is loaded in each recognition step. To create your first test with the RTEC-unit-tester create a file with the above narrative and additionally create the appropriate rules and declarations file in the RTEC form.

\subsection{Test Cases}

 There are three ways of declaring a test case depending on the type of the narrative.
 $\mathit{testCase[E/SE](ScenarioID,TestName,TestID,ExpectedResuts,(Step,WM,StartTime,EndTime))}$ is a fact holding information for identifying the test case,
 the narrative, and the values required for each recognition step. $ScenarioID$ is the name of the narrative, $TestName$ is the name of the test (e.g., cycles), $TestID$ is a 
 number used for the identification of each test, $ExpectedResults$ is a list containing the expected result for each recognition query, and the tuple argument contains the necessary values for event recognition. $Step$ is used for the calculation of query times, $WM$ is the window size, $StarTime$ is the time from which we calculate the first query time, and $EndTime$ is the time of the last query time. For example the tuple (5,6,0,20) would create the following ER periods {(-1,5],(4,10],(9,15],(14,20]}. However, as you probably have noticed in the $testCase[E/SE]$ declaration there isn't regarding the testing fluent, to this end for each testCase a $check(TestName,TestID,Interval)$ rule describing the test must be defined, $TestName,TestID$ are the test name and the test id of the corresponding test case. For example consider the following testcases:
 \begin{lstlisting}[language=Prolog]
%uses Type A narrative
testcase(exampleScenario,example,1, [[(2,11)]],(10,10,0,10)).

%uses Type B narrative
testcaseE(exampleScenario,example,2, [[(2,inf)],[(2,11)]],(5,5,0,10)).

%uses Type C narrative
%expected results of the first query is wrong
testcaseSE(exampleScenario,example,3, [[(2,3)],[(2,11)]],(5,5,0,10)). 

%defining a check rule for the above test cases
check(example,N,I):-
    member(N,[1,2,3]),
    holdsFor(runningTest(unit_tester)=true,I).
\end{lstlisting}
To continue create your first unit-tester tests create a prolog file loading the unit-tester, the compiled rules, the declarations, the narratives and then copy the above prolog code.

\section{Running the tests}
Running the unit tests, simply requires loading a testfile and then typing ``runtests.'' An example execution of the set of unit tests described in the above sections is the following:
 \begin{lstlisting}[language=Prolog]
  ?- ['example_test.prolog'].
  ?- runtests.
Case name: example	Case number: 1	Status: passed

Case name: example	Case number: 2	Status: passed

Case name: example	Case number: 3	Status: failed
-ER number: 0
--TP: [(2,3)]
--FP: [(3,inf)]
--FN: []

Tests passed: 2
Tests failed: 1
yes
\end{lstlisting}

As you can see, test 1 and tests 2 passed and test 3  failed as expected. ER number is the the query number starting from zero.

\end{document}